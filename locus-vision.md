# Locus — 構想・機能・戦略まとめ

strategy/CLAUDE.md から抽出したLocusに関する構想の全体像。
Locusプロジェクト側で設計・実装の参照文書として使う。

---

## 名称とコンセプト

**名称:** Locus（ローカス）
- ラテン語で「場所」「中心点」
- locus of control（統制の所在）= 自分の人生を自分でコントロールする心理学概念
- 「意図の起点」「すべてが始まる場所」を一語で表す
- 「Locus Editor」ではなく「Locus」単体（エディタに留まらないビジョンを表現）

---

## 現状

- Apache + ローカルブラウザ + JS（レガシー）
- 15年間運用してきた階層型テキストエディタ
- 階層管理・思考支援・タスク分解に特化
- 隠蔽機能による集中モード

---

## プロダクトビジョン

```
目標入力 → AI戦略分解 → 階層タスク化 → 実行 → AIフィードバック → 戦略修正
```

**一言定義:**
> Locus = 「欲望を構造化し、結果を承認する」場所

**本質:**
```
Locus = 「人間の欲望」と「AIの実行」の接点

欲望 → 構造化 → 指示 → 実行(AI) → 結果 → 承認(人間)
         ↑_______Locusが担う領域_______↑
```

---

## 戦略的位置づけ

### OSレイヤー仮説

```
従来の認識: タスク管理アプリ（Appレイヤー）
再定義: AIオーケストレーションの統合基盤（OSレイヤー）
※「検証すべき仮説」であり、市場で証明される必要がある
```

| レイヤー | 特性 | Locusの狙い |
|---------|------|-------------|
| App | 代替品多い、スイッチングコスト低 | ここではない |
| OS/Platform | すべての起点、他を従える | ここを狙う（仮説） |

### カスタムハーネス / メタハーネス

```
レイヤー3: メタハーネス（戦略・統括）← Locusの進化形
    ↓
レイヤー2: カスタムハーネス（実行・制御）
    ↓
レイヤー1: AIモデル（処理）
```

| 役割 | 内容 |
|------|------|
| 戦略の定義 | 目標・優先順位を階層構造で管理 |
| タスクの分配 | 「これはCursor」「これはClaude Code」と振り分け |
| 結果の集約 | 成果を受け取り、次の戦略を調整 |
| 文脈の保持 | 長期的なコンテキストを維持（AIの弱点を補完） |

### 「すべてのタスクの起点」

```
Locus = 「一人で生きる」ための思考・実行の中枢
  ├── 経済的自立の管理（SaaS、Upwork案件）
  ├── 思考の自立（戦略立案、知識外部化）
  ├── 安心の自立（NAGI/Sentinel連携）
  └── 創作の自立（ワークフロー管理）
```

### メタであり続ける条件

```
欲望・目的（人間）
    ↓
Locus（意図の構造化）← ここを死守
    ↓
メタハーネス（統括）
    ↓
ハーネス（実行）
    ↓
モデル（処理）
```

守るべき位置 = 「意図の起点」。AIが「あなたはこれを望んでいるのでは？」と提案し始めても、決定権を渡さない設計を維持する。

**起点はローカルになければならない。** クラウド上の起点は他者のサーバーに依存しており、サービス停止・規約変更・データ流出で失われうる。「すべての起点」を他人に預けることは、コントロールを手放すことと同義。AIオーケストレーションの司令塔がローカルにあることは思想的な根幹であり、クラウド型ツール（Workflowy、Taskade等）には構造的に取れないポジションである。

### 一点集中型・多面展開

```
❌ 3-5本のSaaSに分散
✓ Locusを統合基盤として集中
✓ NAGI、Sentinel等は「エディタの手足（プラグイン）」として派生
```

---

## 想定機能

### コア機能

| 機能 | 内容 |
|------|------|
| AI戦略分解 | 目標を実行可能なステップに自動分解 |
| 階層タスク管理 | ドラッグ&ドロップ、サブタスク展開 |
| 隠蔽/集中モード | 今やるべき1つにフォーカス |
| 進捗フィードバック | AIが状況に応じて戦略を動的調整 |
| 複数AI連携 | Claude/GPT/Geminiの意見を並列取得 |

### AI機能: 戦略連動型タスクリスト自動生成

「今何をすべきか」を考える時間を削減する。

```
戦略文書（claude.md的なもの）
  ↓ AIが読み込み
現状把握（進捗、時間、リソース、体調）
  ↓ AIが判断
「今やるべきこと」リストを自動生成
  ↓
ユーザーは選ぶ/承認するだけ
```

**本質: 秘書機能のAI化**

| 秘書の機能 | AIによる実現 |
|-----------|-------------|
| 経営者の意図・目標を理解 | 戦略文書を読み込む |
| スケジュール管理、優先順位付け | 現状把握→タスクリスト生成 |
| 「今日やるべきこと」のリスト化 | 戦略連動型タスクリスト |
| 経営者の状態を考慮 | コンテキスト入力（体調、時間） |
| 判断を仰ぐべきことを選別 | HITL（承認ポイントの設計） |

### AI機能: 選択肢ベースの要件定義・仕様設計

自由記述ではなく、AIが選択肢を提示し、ユーザーが選ぶことで要件を固めていく。

- 言語化が苦手なユーザーでも使える
- 「何を望んでいるか分からない」状態から段階的に具体化
- チャットUIの限界（空のテキストボックス問題）を克服
- 「書く」から「選ぶ・直す」への転換

### インタラクション設計原則: Pull型 → Push型への移行

| 形式 | 動作 | 人間の負荷 |
|------|------|-----------|
| 質問形式（Pull型） | AI「AとBどちらにしますか？」→ 人間が考えて答える | 高（ゼロから判断） |
| 提案形式（Push型） | AIが決めて提示 → 人間が「OK」か「ここを直して」 | 低（レビューのみ） |

**核心: 「ゼロから選ぶ」より「チェックする」方が判断コストは圧倒的に低い。**

- 質問形式が有効なのは、AIに判断材料が足りない初期段階のみ
- 文脈が揃えば提案形式に移行すべき
- 選択肢ベースの要件定義は「入口」として有効だが、本命は「AIが全部決めて出す → 人間はレビューだけ」の提案形式
- Claude Codeのプランモードが好例: AIが計画を立て、人間は承認か修正指示のみ

**設計上の核心: Push型をデフォルトとし、必要な時だけPull型に降りる動的切り替え。**

```
Push型（提案） ← デフォルト
  ↓ 判断材料が足りない時だけ
Pull型（質問） ← 一時的に降りる
  ↓ 答えを得たら
Push型に戻る
```

優秀な秘書のアナロジー:
- 普段は自分で判断して「これでいきます」と提示する（Push型）
- 判断材料が本当に足りない時だけ「これは確認させてください」と聞く（Pull型）
- 答えを得たらすぐPush型に戻る
- **常に聞いてくる秘書は無能、聞くべき時に聞かない秘書は危険。降りるタイミングの判断力が本質。**

### 外部コンテキスト連携（ハブ設計）

| カテゴリ | 連携先例 |
|---------|---------|
| 身体 | スマートウォッチ、睡眠トラッカー |
| 環境 | カレンダー、天気、位置情報 |
| 仕事 | GitHub、Upwork、メール |
| 金融 | 銀行口座、請求書 |

**設計原則: ハブに徹する（自前実装しない、API/MCPで連携）**

### 進捗管理

- 進捗管理が苦手なオーナーの特性を「設計のヒント」として活用
- 「進捗を追わなくても回る設計」を志向
- 「進捗自動検出・報告」（AIが状態を推論、異常時のみ通知）

### n8nとの連携

```
Locus（脳）= 何をやるか（思考・戦略）
n8n（手足）= どう実行するか（実行・自動化）
```

Locusでタスクを定義 → n8nワークフローに委任 → 承認依頼が届く → 結果を反映

---

## UI設計思想

### ポスト・チャットUI / 司令塔UI

| 比較 | チャットUI | ポスト・チャットUI |
|------|-----------|-----------------|
| ユーザー負担 | プロンプトの構築 | 提示された選択肢の承認・修正 |
| 表示形式 | 逐次的なメッセージ（線） | 構造化されたキャンバス（面） |
| 操作感 | 言語化能力が必須 | 直感的なボタン操作 |

**オーケストレーター用インターフェースの3要素:**

| 要素 | 内容 |
|------|------|
| Pipeline View | ワークフローの可視化（カンバン、プログレスバー） |
| Review Gallery | 成果物の承認・修正専用画面（書くのではなく選ぶ・直す） |
| Agent Handover | エージェント間のリレー監視（通信記録の要約表示） |

**最終形のイメージ:**
```
[目標入力] → [AI戦略提案] → [承認/修正] → [エージェント群が実行]
                ↑                              ↓
            [学習・最適化] ←← [結果フィードバック]
```

### 階層型 vs ネットワーク型

| 観点 | 階層型 | ネットワーク型 |
|------|--------|---------------|
| 強み | 順序・構造・実行 | 発見・連結・探索 |
| 向く用途 | 執筆、計画、手順書 | 知識蓄積、アイデア発見 |
| AI親和性 | 文脈がパスに限定 | RAG向き |

**「欲望の構造化」には階層型が本質的に適している。**

**進化パス:**
```
今: 純粋階層
  ↓
次: 階層 + タグ（1ノードを複数文脈に）
  ↓
将来: 必要ならネットワーク的な表示も追加
```

---

## 設計原則

### AIが進化すると得をする構造

| 原則 | 内容 |
|------|------|
| AIの「上流」に位置 | AIに何をやらせるかを決める側 |
| AIの出力の「受け皿」 | 生成物を蓄積・構造化・再利用 |
| 「組み込む」ではなく「接続」 | 特定AIに依存せず、乗り換え可能 |
| 自動化範囲がAIと共に拡大 | AIが賢くなる→承認だけで済む範囲が増える |
| 代替困難な部分に価値 | 構造・習慣・蓄積・長期文脈 |

### プライバシーファースト

「欲望の構造化」が扱うデータは最も個人的。大手に預けたくない。

- ローカルファースト（データは端末に）
- クラウド同期はオプション（E2E暗号化）
- セルフホスト可能
- コード公開で信頼を担保

**大手には真似できない構造的優位性。** ビジネスモデルが違うため、大手が「データを収集しない」設計を採用することは困難。

**参考モデル: Obsidian**
- ローカルファーストのMarkdownエディタとして成功
- アプリ無料、Sync（月$8）とPublish（月$16）で課金
- 小規模チームで高収益を実現
- データの主権はユーザーに残し、クラウドは「便利なオプション」として販売
- Locusと同じ設計思想（ローカル+オプショナルクラウド）でビジネスが成立する先例

### エコシステム戦略

```
自分が必要な機能 → 自分で作る（コア）
自分が必要でない機能 → 他人が作れるようにする（プラグイン/API）
```

### 時間軸での進化設計

```
現在: AIができないことが多い → それを補う機能を提供
  ↓
中期: AIが進化 → 一部を手放し、より上位へ移行
  ↓
長期: 欲望の構造化 + 承認 に収束
```

**現時点でAIができないこと（取り込むべき機能）:**

| 現在の弱点 | Locusで補う |
|-----------|-------------|
| 長期的文脈の保持 | 過去の決定・経緯を構造化して保持 |
| 検証の設計 | 「何をもって成功とするか」の定義支援 |
| 複数AIの統合 | 異なるハーネスの結果を一箇所に集約 |
| 暗黙知の構造化 | 言語化しにくい判断基準を明文化 |

---

## 競合分析

| カテゴリ | 代表例 | 限界 |
|---------|--------|------|
| アウトライナー | Workflowy, Dynalist | 実行・AI連携が弱い |
| タスク管理 | Todoist, Asana | 思考の構造化が弱い |
| ノート + AI | Notion AI, Obsidian | AIは補助的、中核ではない |
| 最も近い競合 | Taskade | エージェント統括の深さは未知 |

**市場機会の評価:**
| 観点 | 評価 |
|------|------|
| 競合の少なさ | ★★★ |
| 需要の顕在化 | ★★（まだ潜在的） |
| 技術的タイミング | ★★★ |
| 差別化の余地 | ★★★ |

**大手との競合リスク:**
- 勝ち筋はニッチ特化（「一人で生きる」人、オーケストレーター志向）
- 大手はこのニッチを狙わない（市場が小さすぎると判断する）

---

## リスクと対策

| リスク | 対策 |
|--------|------|
| PMF未達成 | Upworkを「探索装置」として市場検証を続ける |
| バス係数1 | OSS化、エスクロー条項、セルフホスト可能設計 |
| 大手参入 | ニッチ特化 + ドッグフーディングの深さ |
| SaaS終焉論 | AIの上に座るOS。機能ではなく構造・蓄積・習慣を売る |

---

## ターゲット

- フリーランサー、起業家、PM、コンサルタント（「考えること」が仕事の人）
- 「一人で生きる」人、オーケストレーター志向、対人関係を最小化したい人

---

## 開発方針

**「自分のために作り、使い倒し、その過程で磨かれたものを後から売る」**

- ドッグフーディング = 自分が使い続ける限り改良が止まらない
- 最悪でも「自分用の最高のツール」が残る
- 市場を気にしすぎない（売れそうな機能→自分が使わない→改良されない）

**並行開発戦略:**
1. Upwork立ち上げ → 収入の柱を確保
2. 空き時間でNext.jsリビルド開始（自分用）
3. 使いながら改善 → AI機能を追加
4. Upwork月50万円超えたら、プロダクトへの時間配分を増やす
5. β公開 → フィードバック収集 → 正式リリース

---

## 尖ったコンセプトの可能性（検討中）

- 「効率化・自動化設計ツール」として特化する方向性
- プロセス分解 → 6レイヤー分析 → ボトルネック検出 → 自動化提案
- 自分を「自動化スペシャリスト」としてブランディングすれば相乗効果

---

## Locusの構造イメージ

```
Locus
│
├── 【欲望】経済的自由を得て、創作に没頭したい
│   │
│   ├── 【目標】自動化フロー月100万円
│   │   │
│   │   ├── 【戦略】Upwork → SaaS
│   │   │   │
│   │   │   └── 【タスク】→ AIエージェントへ
│   │   │             ↓
│   │   │         【結果】← AIから返ってくる
│   │   │             ↓
│   │   │         【承認】これでいい / やり直し ← 人間
│   │   │
│   │   └── 【決定ログ】2026-01-30: 〇〇を承認
```

---

## ユーザー獲得

| 段階 | 方法 | 自動化度 |
|------|------|---------|
| 0 | 直接営業 | なし |
| 1 | Product Hunt等で露出 | 低 |
| 2 | SEO/コンテンツ→検索流入 | 中 |
| 3 | 口コミ/紹介の仕組み化 | 高 |
| 4 | プロダクト自体が拡散（バイラル設計） | 最高 |

**バイラル案:** エクスポートに「Made with Locus」、テンプレート共有機能

---

## OSSモデル（選択肢として保持）

```
OSSで無料公開 → 大量ユーザー獲得 → 「自分で運用したくない層」がクラウド版に課金
```

PMF検証後の選択肢として頭に入れておく。
