# Locus — Next.js モダン化

## このプロジェクトについて
Perl CGI 製の階層型エディタ「Locus」を Next.js で段階的にモダン化する。
現行の Perl 版 (`../v2/`) はそのまま残し、並行して動かす。

## プロダクトビジョン
Locusは単なるエディタではなく、「欲望を構造化し、AI群に実行させ、結果を承認する」統合基盤を目指している。
現在の階層型エディタはその土台。**機能の優先順位、アーキテクチャ判断、AI連携の設計**に迷ったときは `locus-vision.md` を参照すること。

## 設計方針
- **常に販売できる品質**: 個人用ツールではなく、製品として出せるレベルを維持する
- **他人でも使える**: 作者以外が触っても迷わないUIにする
- **直感に反しない**: ユーザーが「こう動くだろう」と期待する通りに動くこと
- **既存ツールの操作感を踏襲**: 独自のキーバインドや操作体系を発明しない
- **キーボードファースト**: マウスなしでも全操作ができることを目指す

## データ形式: memo.cgi

データファイルのパス: `../v2/data/memo/memo.cgi`（読み取り専用で参照）

### フォーマット仕様
- 1行1ノード。先頭のスペース数がインデント（ツリー深さ）を表す
- ルートノードはインデント0（行頭にスペースなし）
- 子ノードは親より1スペース多い
- `!{close}` — 直前のノードが折り畳まれていることを示すメタ行（表示しない）
- エンコーディング: `%{n}` → 改行、`%{s}` → スペース

### データ例
```
root
 覚書
  !{close}
  デザイン
   !{close}
   design_list
    !{close}
    情報を伝えること%{n}情報のリスト
  コーディング
   !{close}
   pandas
    !{close}
    ■特定の行を取得する方法%{n}loc%{s}%{s}=%{s}ラベル名で取得
 タスク
  _archive
   !{close}
   jonaron
```

### パース規則
1. 各行の先頭スペース数を数えてインデントレベルとする
2. `!{close}` の行はメタ情報。直前のノードの `closed: true` にする
3. テキスト中の `%{n}` は改行、`%{s}` はスペースにデコードする
4. ルートノード（1行目の `root`）は表示しない。その子がトップレベルノード
5. ノードID は行番号（0始まり）を使う。ただし `!{close}` 行はスキップ

## Phase 1 のゴール
ブラウザでツリーが表示され、キーボードで選択移動できる状態。

## Phase 1 実装タスク

### 1. API Route: memo.cgi パーサー
**ファイル**: `src/app/api/tree/route.ts`

- `../v2/data/memo/memo.cgi` を `fs.readFileSync` で読み込む
- インデントを解析してツリー構造の JSON を返す
- `!{close}` を検出して `closed` フラグを設定
- `%{n}`, `%{s}` をデコード

レスポンス形式:
```json
{
  "nodes": [
    {
      "id": 1,
      "text": "覚書",
      "indent": 1,
      "closed": true,
      "children": [
        {
          "id": 3,
          "text": "デザイン",
          "indent": 2,
          "closed": true,
          "children": [...]
        }
      ]
    }
  ]
}
```

### 2. ツリー表示コンポーネント
**ファイル**:
- `src/app/page.tsx` — メインページ。`fetch('/api/tree')` でデータ取得
- `src/app/components/TreeNode.tsx` — 再帰的ノード描画コンポーネント

要件:
- 各ノードをクリックで選択（React state で管理）
- 選択中ノードはハイライト表示
- `closed` なノードは子を非表示（折り畳み表示）
- インデントは `paddingLeft` で表現

### 3. キーボード操作（Phase 1 最小セット）
- `↑` / `↓`: 表示中ノード間の選択移動（closedの子はスキップ）
- `Escape`: 選択解除

## 現行 Perl 版のキーボード操作（将来の実装対象）
以下は Phase 2 以降で実装する。Phase 1 では ↑↓ と Escape のみ。
- →: 展開 / 最初の子へ移動
- ←: 折り畳み / 親へ移動
- Alt+↑↓: 兄弟間の上下移動
- Alt+→←: インデント / アウトデント
- Tab: 子ノード追加
- Delete: 削除
- F2: 編集
- Ctrl+Enter: 編集確定

## Phase ロードマップ

| Phase | 内容 |
|-------|------|
| Phase 1 | ツリー表示 + ↑↓選択 + Escape（今回） |
| Phase 2 | キーボードでの構造操作（→← 展開/折り畳み, Alt+矢印, Tab, Delete, F2 等） |
| Phase 3 | ドラッグ＆ドロップ（`@dnd-kit/core` 等で実装。キーボード操作が先に完成していること前提） |

D&D は Phase 3。キーボードで全操作が完結する状態を先に作り、D&D は「便利なショートカット」として後から載せる。

## テスト駆動の導入方針

ユーザーはテスト駆動開発を習得中。以下のルールで進める。

### Claudeへの指示
- **新機能を実装する前に、必ずユーザーにテストの話をする**。「この機能、先にテストを書いてみませんか？」と提案する
- テストは難しくなくていい。「こう操作したら、こうなるべき」を1つだけ書くところから始める
- ユーザーがテストを書くのを手伝う。書き方を教え、一緒に書く
- テストが通ることを確認してから実装に入る
- 実装後、テストが通ることをユーザーに見せる

### テストの方針
- ツリー操作のロジック（treeUtils.ts）は単体テストで検証する
- 「ノードを削除して Undo したら元に戻る」のような操作シナリオをテストにする
- 最初から完璧を目指さない。1機能1テストから始める

## 技術スタック
- Next.js (App Router) + TypeScript
- Tailwind CSS
- React state（外部状態管理ライブラリは不要）

## ディレクトリ構成
```
v2_modern/
├── src/app/
│   ├── api/tree/route.ts    ← memo.cgi パーサー
│   ├── components/
│   │   └── TreeNode.tsx     ← ノード描画
│   ├── page.tsx             ← メインページ
│   └── layout.tsx           ← レイアウト（生成済み）
├── CLAUDE.md                ← このファイル
└── ...
```
